<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>画像放り込み円グラフメーカー</title>
　　<link rel="icon" href="favicon6.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&family=Yuji+Syuku&family=Lobster&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
        }
        .dragging-handle {
            cursor: ew-resize;
        }
        /* スクロールバー */
        .sidebar-content::-webkit-scrollbar { width: 8px; }
        .sidebar-content::-webkit-scrollbar-track { background: #f1f1f1; }
        .sidebar-content::-webkit-scrollbar-thumb { background: #888; border-radius: 4px; }
        .sidebar-content::-webkit-scrollbar-thumb:hover { background: #555; }
        .drag-area {
            border: 2px dashed #ccc;
            border-radius: 0.5rem;
            padding: 2rem;
            text-align: center;
            color: #aaa;
            transition: background-color 0.2s;
        }
        .drag-area.drag-over {
            background-color: #e0e7ff;
            border-color: #6366f1;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col h-screen">

    <!-- ヘッダーメニュー -->
    <header class="bg-white shadow-md w-full p-2 flex items-center justify-between z-20">
        <h1 id="app-title" class="text-xl font-bold text-gray-700">画像放り込み円グラフメーカー</h1>
        <div id="top-menu" class="flex items-center space-x-4">
            <div class="flex items-center space-x-2">
                <button id="export-btn" class="px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-purple-600 transition">画像出力</button>
                <button id="help-btn" class="px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-green-600 transition">操作方法</button>
            </div>
            <span class="text-gray-300">|</span>
            <div class="flex items-center space-x-2">
                <button id="save-btn" class="px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition">保存</button>
                <button id="load-btn" class="px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition">呼び出し</button>
                <input type="file" id="load-input" class="hidden" accept=".json">
            </div>
            <span class="text-gray-300">|</span>
            <div class="flex items-center space-x-2">
                <button id="lang-toggle-btn" class="px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition">English</button>
            </div>
        </div>
    </header>

    <div class="flex flex-1 overflow-hidden">
        <!-- 左パネル -->
        <aside id="left-panel" class="w-1/4 bg-white shadow-lg transition-all duration-300 ease-in-out z-10 flex flex-col">
            <div class="p-4 border-b flex justify-between items-center">
                <h2 id="panel-title" class="text-lg font-bold">設定</h2>
                <button id="panel-back-btn" class="hidden px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition">戻る</button>
            </div>
            <div class="flex-1 overflow-y-auto sidebar-content p-4">
                <!-- 設定ビュー -->
                <div id="settings-view">
                    <div class="space-y-4 pt-4 border-t">
                        <h4 id="display-options-title" class="font-semibold">表示オプション</h4>
                        <div class="mb-4">
                            <label for="line-width-slider" class="block text-sm font-medium text-gray-700 mb-1"><span id="line-width-label-text">線の太さ</span> (<span id="line-width-value">2</span>px)</label>
                            <input type="range" id="line-width-slider" min="1" max="10" value="2" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <div class="mb-4">
                            <label id="percent-size-label" for="percent-size-select" class="block text-sm font-medium text-gray-700 mb-1">パーセント文字サイズ</label>
                            <select id="percent-size-select" class="w-full p-2 border border-gray-300 rounded-md">
                                <option value="10">極小</option>
                                <option value="12">小</option>
                                <option value="14">中</option>
                                <option value="16">大</option>
                                <option value="20" selected>特大</option>
                                <option value="24">最大</option>
                                <option value="28">超特大</option>
                            </select>
                        </div>
                        <div class="mb-4">
                            <label id="percent-color-label" for="percent-color-input" class="block text-sm font-medium text-gray-700 mb-1">パーセント文字色</label>
                            <input type="color" id="percent-color-input" value="#555555" class="mt-1 p-1 h-10 w-full border border-gray-300 rounded-md">
                        </div>
                    </div>
                    <div class="space-y-4 pt-4 border-t">
                        <h4 id="bg-image-title" class="font-semibold">背景画像</h4>
                        <div><label id="bg-area-color-label" for="bg-area-color-input" class="block text-sm font-medium text-gray-700 mb-1">背景エリアの色</label><input type="color" id="bg-area-color-input" value="#ffffff" class="mt-1 p-1 h-10 w-full border border-gray-300 rounded-md"></div>
                        <div id="bg-drag-area" class="drag-area">ここに背景画像をドロップ</div>
                        <div id="bg-image-controls" class="hidden space-y-4">
                            <div><label for="bg-opacity-slider" class="block text-sm font-medium text-gray-700"><span id="bg-opacity-label-text">透過度</span> (<span id="bg-opacity-value">100</span>%)</label><input type="range" id="bg-opacity-slider" min="0" max="100" value="100" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"></div>
                            <div><label for="bg-scale-slider" class="block text-sm font-medium text-gray-700"><span id="bg-scale-label-text">拡大・縮小</span> (<span id="bg-scale-value">100</span>%)</label><input type="range" id="bg-scale-slider" min="10" max="300" value="100" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"></div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700"><span id="bg-pos-label-text">位置</span></label>
                                <input type="range" id="bg-x-slider" min="-100" max="100" value="0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" title="横位置">
                                <input type="range" id="bg-y-slider" min="-100" max="100" value="0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer mt-2" title="縦位置">
                            </div>
                            <div class="flex space-x-2">
                                <button id="reset-bg-image-btn" class="w-full px-4 py-2 bg-orange-500 text-white rounded-lg hover:bg-orange-600 transition">背景画像設定をリセット</button>
                                <button id="delete-bg-image-btn" class="w-full px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition">画像を削除</button>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- ヘルプビュー -->
                <div id="help-view" class="hidden">
                     <ul id="help-list" class="space-y-3 text-sm list-disc list-inside"></ul>
                </div>
                <!-- 画像出力ビュー -->
                <div id="export-view" class="hidden space-y-4">
                    <div><label id="export-size-label" for="export-size-select" class="block text-sm font-medium text-gray-700 mb-1">画像サイズ</label><select id="export-size-select" class="w-full p-2 border border-gray-300 rounded-md"><option value="800">800x800</option><option value="1200" selected>1200x1200</option><option value="2000">2000x2000</option></select></div>
                    <div><label id="export-format-label" for="export-format-select" class="block text-sm font-medium text-gray-700 mb-1">画像形式</label><select id="export-format-select" class="w-full p-2 border border-gray-300 rounded-md"><option value="image/png">PNG</option><option value="image/jpeg">JPEG</option></select></div>
                    <button id="export-confirm-btn" class="w-full px-4 py-2 bg-purple-500 text-white rounded-lg hover:bg-purple-600 transition">出力実行</button>
                </div>
                <!-- 編集ビュー -->
                <div id="edit-view" class="hidden space-y-4">
                    <div class="flex items-center space-x-2">
                        <div class="flex-1"><label id="edit-color-label" class="block text-sm font-medium text-gray-700">背景色</label><input type="color" id="edit-color" class="mt-1 p-1 h-10 w-full border border-gray-300 rounded-md"></div>
                        <div class="flex-1"><label for="edit-color-opacity" class="block text-sm font-medium text-gray-700"><span id="edit-color-opacity-label-text">透過度</span> (<span id="color-opacity-value">100</span>%)</label><input type="range" id="edit-color-opacity" min="0" max="100" value="100" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"></div>
                    </div>
                    <div id="image-edit-section" class="space-y-4 pt-4 border-t">
                        <h4 id="edit-image-title" class="font-semibold">画像の調整</h4>
                        <div><label for="edit-image-scale" class="block text-sm font-medium text-gray-700"><span id="edit-image-scale-label-text">拡大・縮小</span> (<span id="scale-value">100</span>%)</label><input type="range" id="edit-image-scale" min="10" max="500" value="100" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"></div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700"><span id="image-pos-label-text">位置</span></label>
                            <input type="range" id="edit-image-x" min="-100" max="100" value="0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" title="横位置">
                            <input type="range" id="edit-image-y" min="-100" max="100" value="0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer mt-2" title="縦位置">
                        </div>
                        <button id="delete-image-btn" class="w-full px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition">画像を削除</button>
                    </div>
                    <div class="space-y-4 pt-4 border-t">
                        <h4 id="edit-text-title" class="font-semibold">テキストの編集</h4>
                        <div><label id="edit-text-content-label" for="edit-text" class="block text-sm font-medium text-gray-700">内容</label><input type="text" id="edit-text" class="mt-1 p-2 w-full border border-gray-300 rounded-md"></div>
                        <div>
                            <label id="edit-font-label" for="edit-font-select" class="block text-sm font-medium text-gray-700">フォント</label>
                            <select id="edit-font-select" class="w-full p-2 border border-gray-300 rounded-md mt-1">
                                <option value="'Noto Sans JP', sans-serif">Noto Sans JP (ゴシック)</option>
                                <option value="'Yuji Syuku', serif">Yuji Syuku (明朝)</option>
                                <option value="'Roboto', sans-serif">Roboto (英字)</option>
                                <option value="'Lobster', cursive">Lobster (英字デザイン)</option>
                            </select>
                        </div>
                        <div class="flex items-center space-x-2">
                             <div class="w-1/4"><label id="edit-text-color-label" class="block text-sm font-medium text-gray-700">文字色</label><input type="color" id="edit-text-color" value="#000000" class="mt-1 p-1 h-10 w-full border border-gray-300 rounded-md"></div>
                             <div class="flex-1"><label for="edit-text-size" class="block text-sm font-medium text-gray-700"><span id="edit-text-size-label-text">サイズ</span> (<span id="text-size-value">20</span>px)</label><input type="range" id="edit-text-size" min="8" max="48" value="20" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"></div>
                        </div>
                        <div class="flex space-x-4 items-center">
                            <label class="flex items-center"><input type="checkbox" id="font-bold-checkbox" class="mr-1"><span id="font-bold-label">太字</span></label>
                            <label class="flex items-center"><input type="checkbox" id="font-italic-checkbox" class="mr-1"><span id="font-italic-label">斜体</span></label>
                            <label class="flex items-center"><input type="checkbox" id="text-shadow-checkbox" class="mr-1"><span id="text-shadow-label">影</span></label>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700"><span id="text-pos-label-text">位置</span></label>
                            <input type="range" id="edit-text-x" min="-100" max="100" value="0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" title="横位置">
                            <input type="range" id="edit-text-y" min="-100" max="100" value="0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer mt-2" title="縦位置">
                        </div>
                    </div>
                     <div class="pt-4 border-t flex space-x-2">
                         <button id="reset-segment-btn" class="w-full px-4 py-2 bg-orange-500 text-white rounded-lg hover:bg-orange-600 transition">パーツ設定をリセット</button>
                         <button id="delete-segment-btn" class="w-full px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition">このパーツを削除</button>
                    </div>
                </div>
            </div>
        </aside>

        <!-- メインコンテンツ -->
        <main class="flex-1 flex items-center justify-center p-4 bg-gray-200">
            <canvas id="schedule-canvas" class="bg-white rounded-full shadow-xl"></canvas>
        </main>
    </div>
    
    <!-- 確認・通知モーダル -->
    <div id="modal-container" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white rounded-lg p-6 shadow-2xl w-full max-w-sm mx-auto">
            <h3 id="modal-title" class="text-lg font-bold mb-4"></h3>
            <p id="modal-message" class="mb-6"></p>
            <div id="modal-buttons" class="flex justify-end space-x-4">
                <button id="modal-cancel" class="px-4 py-2 bg-gray-300 rounded-lg hover:bg-gray-400">いいえ</button>
                <button id="modal-confirm" class="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600">はい</button>
                 <button id="modal-ok" class="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 w-full">OK</button>
            </div>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('schedule-canvas');
            const ctx = canvas.getContext('2d');

            // --- DOM要素 ---
            const appTitle = document.getElementById('app-title');
            const panelTitle = document.getElementById('panel-title');
            const panelBackBtn = document.getElementById('panel-back-btn');
            const helpBtn = document.getElementById('help-btn');
            const saveBtn = document.getElementById('save-btn');
            const loadBtn = document.getElementById('load-btn');
            const loadInput = document.getElementById('load-input');
            const exportBtn = document.getElementById('export-btn');
            const langToggleBtn = document.getElementById('lang-toggle-btn');
            const settingsView = document.getElementById('settings-view');
            const helpView = document.getElementById('help-view');
            const exportView = document.getElementById('export-view');
            const editView = document.getElementById('edit-view');
            
            const modalContainer = document.getElementById('modal-container');
            const modalTitle = document.getElementById('modal-title');
            const modalMessage = document.getElementById('modal-message');
            const modalButtons = document.getElementById('modal-buttons');
            const modalConfirmBtn = document.getElementById('modal-confirm');
            const modalCancelBtn = document.getElementById('modal-cancel');
            const modalOkBtn = document.getElementById('modal-ok');


            const exportSizeSelect = document.getElementById('export-size-select');
            const exportFormatSelect = document.getElementById('export-format-select');
            const exportConfirmBtn = document.getElementById('export-confirm-btn');
            
            const editColorInput = document.getElementById('edit-color');
            const editColorOpacity = document.getElementById('edit-color-opacity');
            const colorOpacityValue = document.getElementById('color-opacity-value');
            const editTextInput = document.getElementById('edit-text');
            const editFontSelect = document.getElementById('edit-font-select');
            const editTextColorInput = document.getElementById('edit-text-color');
            const edittextsize = document.getElementById('edit-text-size');
            const textSizeValue = document.getElementById('text-size-value');
            const fontBoldCheckbox = document.getElementById('font-bold-checkbox');
            const fontItalicCheckbox = document.getElementById('font-italic-checkbox');
            const textShadowCheckbox = document.getElementById('text-shadow-checkbox');
            const editTextX = document.getElementById('edit-text-x');
            const editTextY = document.getElementById('edit-text-y');
            const imageEditSection = document.getElementById('image-edit-section');
            const editImageScale = document.getElementById('edit-image-scale');
            const scaleValue = document.getElementById('scale-value');
            const editImageX = document.getElementById('edit-image-x');
            const editImageY = document.getElementById('edit-image-y');
            const deleteImageBtn = document.getElementById('delete-image-btn');
            const deleteSegmentBtn = document.getElementById('delete-segment-btn');
            const resetSegmentBtn = document.getElementById('reset-segment-btn');
            
            const bgDragArea = document.getElementById('bg-drag-area');
            const bgImageControls = document.getElementById('bg-image-controls');
            const bgOpacitySlider = document.getElementById('bg-opacity-slider');
            const bgOpacityValue = document.getElementById('bg-opacity-value');
            const bgScaleSlider = document.getElementById('bg-scale-slider');
            const bgScaleValue = document.getElementById('bg-scale-value');
            const bgXSlider = document.getElementById('bg-x-slider');
            const bgYSlider = document.getElementById('bg-y-slider');
            const deleteBgImageBtn = document.getElementById('delete-bg-image-btn');
            const resetBgImageBtn = document.getElementById('reset-bg-image-btn');
            const bgAreaColorInput = document.getElementById('bg-area-color-input');

            const lineWidthSlider = document.getElementById('line-width-slider');
            const lineWidthValue = document.getElementById('line-width-value');
            const percentSizeSelect = document.getElementById('percent-size-select');
            const percentColorInput = document.getElementById('percent-color-input');

            // --- 状態管理 ---
            const defaultSegmentProps = {
                color: '#ffffff',
                colorOpacity: 1,
                image: null,
                text: '',
                fontFamily: "'Noto Sans JP', sans-serif",
                textColor: '#000000',
                textSize: 20,
                fontWeight: 'normal',
                fontStyle: 'normal',
                textShadow: false,
                textOffsetX: 0,
                textOffsetY: 0
            };
            let settings = { 
                language: 'ja', 
                bgAreaColor: '#ffffff',
                lineWidth: 2,
                percentageFontSize: 20,
                percentageFontColor: '#555555'
            };
            let segments = [{ id: Date.now(), start: 0, end: 24, ...JSON.parse(JSON.stringify(defaultSegmentProps)) }];
            let backgroundImage = null;
            let currentView = 'settings';
            
            let historyStack = [];
            let historyIndex = -1;
            
            let draggingHandle = null;
            let hoveredTick = null;
            let currentlyEditingSegment = null;
            let center, radius;

            // --- 初期化 ---
            function init() {
                resizeCanvas();
                loadSettings();
                addEventListeners();
                updateUIText(settings.language, 'settings');
                saveState();
                draw();
            }

            function resizeCanvas() {
                const main = canvas.parentElement;
                const size = Math.min(main.clientWidth, main.clientHeight) * 0.95;
                canvas.width = size;
                canvas.height = size;
                center = { x: canvas.width / 2, y: canvas.height / 2 };
                radius = canvas.width / 2 * 0.8;
                draw();
            }

            // --- イベントリスナー ---
            function addEventListeners() {
                window.addEventListener('resize', resizeCanvas);
                
                langToggleBtn.addEventListener('click', () => {
                    settings.language = (settings.language === 'ja') ? 'en' : 'ja';
                    updateUIText(settings.language, currentView);
                    saveSettings();
                });

                helpBtn.addEventListener('click', () => switchView('help'));
                saveBtn.addEventListener('click', handleSave);
                loadBtn.addEventListener('click', () => loadInput.click());
                loadInput.addEventListener('change', handleLoad);
                exportBtn.addEventListener('click', () => switchView('export'));
                panelBackBtn.addEventListener('click', () => {
                    currentlyEditingSegment = null;
                    switchView('settings');
                });
                
                canvas.addEventListener('mousemove', handleMouseMove);
                canvas.addEventListener('mousedown', handleMouseDown);
                canvas.addEventListener('mouseup', handleMouseUp);
                canvas.addEventListener('mouseleave', handleMouseLeave);
                canvas.addEventListener('click', handleClick);
                canvas.addEventListener('dblclick', handleDoubleClick);
                
                canvas.addEventListener('dragover', handleDragOver);
                canvas.addEventListener('drop', handleDrop);
                
                exportConfirmBtn.addEventListener('click', handleExport);
                
                lineWidthSlider.addEventListener('input', (e) => {
                    settings.lineWidth = parseInt(e.target.value, 10);
                    lineWidthValue.textContent = e.target.value;
                    saveState();
                    draw();
                    saveSettings();
                });
                percentSizeSelect.addEventListener('change', (e) => {
                    settings.percentageFontSize = parseInt(e.target.value, 10);
                    saveState();
                    draw();
                    saveSettings();
                });
                percentColorInput.addEventListener('input', (e) => {
                    settings.percentageFontColor = e.target.value;
                    saveState();
                    draw();
                    saveSettings();
                });


                editColorInput.addEventListener('input', (e) => { updateSegmentProperty('color', e.target.value); saveState(); });
                editColorOpacity.addEventListener('input', (e) => { updateSegmentProperty('colorOpacity', parseFloat(e.target.value) / 100); colorOpacityValue.textContent = e.target.value; saveState(); });
                editTextInput.addEventListener('input', (e) => { updateSegmentProperty('text', e.target.value); saveState(); });
                editFontSelect.addEventListener('change', (e) => { updateSegmentProperty('fontFamily', e.target.value); saveState(); });
                editTextColorInput.addEventListener('input', (e) => { updateSegmentProperty('textColor', e.target.value); saveState(); });
                edittextsize.addEventListener('input', (e) => { updateSegmentProperty('textSize', parseInt(e.target.value, 10)); textSizeValue.textContent = e.target.value; saveState(); });
                fontBoldCheckbox.addEventListener('change', (e) => { updateSegmentProperty('fontWeight', e.target.checked ? 'bold' : 'normal'); saveState(); });
                fontItalicCheckbox.addEventListener('change', (e) => { updateSegmentProperty('fontStyle', e.target.checked ? 'italic' : 'normal'); saveState(); });
                textShadowCheckbox.addEventListener('change', (e) => { updateSegmentProperty('textShadow', e.target.checked); saveState(); });
                editTextX.addEventListener('input', (e) => { updateSegmentProperty('textOffsetX', parseFloat(e.target.value) / 100); saveState(); });
                editTextY.addEventListener('input', (e) => { updateSegmentProperty('textOffsetY', parseFloat(e.target.value) / 100); saveState(); });
                
                editImageScale.addEventListener('input', (e) => { updateImageProperty('userScale', parseFloat(e.target.value) / 100); scaleValue.textContent = e.target.value; saveState(); });
                editImageX.addEventListener('input', (e) => { updateImageProperty('offsetX', parseFloat(e.target.value) / 100); saveState(); });
                editImageY.addEventListener('input', (e) => { updateImageProperty('offsetY', parseFloat(e.target.value) / 100); saveState(); });
                deleteImageBtn.addEventListener('click', deleteImage);
                deleteSegmentBtn.addEventListener('click', deleteSegment);
                resetSegmentBtn.addEventListener('click', resetSegment);

                bgAreaColorInput.addEventListener('input', (e) => { settings.bgAreaColor = e.target.value; bgDragArea.style.backgroundColor = e.target.value; saveSettings(); saveState(); draw(); });
                bgDragArea.addEventListener('dragover', (e) => { e.preventDefault(); e.stopPropagation(); bgDragArea.classList.add('drag-over'); });
                bgDragArea.addEventListener('dragleave', (e) => { e.preventDefault(); e.stopPropagation(); bgDragArea.classList.remove('drag-over'); });
                bgDragArea.addEventListener('drop', handleBackgroundDrop);
                bgOpacitySlider.addEventListener('input', (e) => { if(backgroundImage) { backgroundImage.opacity = parseFloat(e.target.value) / 100; bgOpacityValue.textContent = e.target.value; saveState(); draw(); } });
                bgScaleSlider.addEventListener('input', (e) => { if(backgroundImage) { backgroundImage.scale = parseFloat(e.target.value) / 100; bgScaleValue.textContent = e.target.value; saveState(); draw(); } });
                bgXSlider.addEventListener('input', (e) => { if(backgroundImage) { backgroundImage.x = parseFloat(e.target.value) / 100; saveState(); draw(); } });
                bgYSlider.addEventListener('input', (e) => { if(backgroundImage) { backgroundImage.y = parseFloat(e.target.value) / 100; saveState(); draw(); } });
                deleteBgImageBtn.addEventListener('click', () => { showConfirmationModal(translations[settings.language].confirmBgImageDeleteTitle, translations[settings.language].confirmBgImageDeleteMessage, () => { backgroundImage = null; bgImageControls.classList.add('hidden'); saveState(); draw(); }); });
                resetBgImageBtn.addEventListener('click', resetBackgroundImage);

                document.addEventListener('keydown', (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                        e.preventDefault();
                        handleUndo();
                    }
                });
            }
            
            /**
             * メインの描画関数。Canvasとエクスポートの両方に対応
             * @param {CanvasRenderingContext2D} targetCtx - 描画対象のコンテキスト
             * @param {{width: number, height: number}} size - 描画サイズ
             * @param {string} format - 出力形式 ('image/png' または 'image/jpeg')
             */
            function draw(targetCtx = ctx, size = {width: canvas.width, height: canvas.height}, format = 'image/png') {
                const localCenter = { x: size.width / 2, y: size.height / 2 };
                const localRadius = size.width / 2 * 0.8;
                const outerRadius = localRadius * 1.25; 

                targetCtx.clearRect(0, 0, size.width, size.height);

                const isExportPng = targetCtx !== ctx && format === 'image/png';

                if (isExportPng) {
                    targetCtx.save();
                    targetCtx.beginPath();
                    targetCtx.arc(localCenter.x, localCenter.y, outerRadius, 0, 2 * Math.PI);
                    targetCtx.clip();
                }

                drawBackground(targetCtx, size);

                if (backgroundImage && backgroundImage.data) {
                    drawBackgroundImage(targetCtx, size);
                }
                
                drawSegments(targetCtx, localCenter, localRadius);
                
                drawSegmentOutlines(targetCtx, localCenter, localRadius);
                drawOuterCircle(targetCtx, localCenter, localRadius);
                
                drawPercentageLabels(targetCtx, localCenter, localRadius);
                
                if (targetCtx === ctx) {
                    drawHoveredTick(targetCtx, localCenter, localRadius);
                }

                if (isExportPng) {
                    targetCtx.restore();
                }
            }

            function drawBackground(targetCtx, size) {
                targetCtx.save();
                targetCtx.fillStyle = settings.bgAreaColor || '#ffffff';
                targetCtx.fillRect(0, 0, size.width, size.height);
                targetCtx.restore();
            }

            function drawBackgroundImage(targetCtx, size) {
                targetCtx.save();
                targetCtx.globalAlpha = backgroundImage.opacity;
                const img = backgroundImage.data;
                const scale = backgroundImage.scale;
                const imgWidth = size.width * scale;
                const imgHeight = (img.height / img.width) * imgWidth;
                const x = (size.width - imgWidth) / 2 + (size.width * backgroundImage.x);
                const y = (size.height - imgHeight) / 2 + (size.height * backgroundImage.y);
                targetCtx.drawImage(img, x, y, imgWidth, imgHeight);
                targetCtx.restore();
            }

            function drawSegments(targetCtx, localCenter, localRadius) {
                segments.forEach(seg => {
                    const startAngle = timeToAngle(seg.start);
                    const endAngle = timeToAngle(seg.end);
                    
                    targetCtx.beginPath();
                    targetCtx.moveTo(localCenter.x, localCenter.y);
                    targetCtx.arc(localCenter.x, localCenter.y, localRadius, startAngle, endAngle);
                    targetCtx.closePath();
                    
                    targetCtx.save();
                    targetCtx.fillStyle = hexToRgba(seg.color || '#ffffff', seg.colorOpacity || 1);
                    targetCtx.fill();
                    targetCtx.restore();

                    if (seg.image && seg.image.data) {
                        targetCtx.save();
                        targetCtx.clip();
                        drawImageInSegment(targetCtx, seg, localCenter, localRadius);
                        targetCtx.restore();
                    }
                    
                    if (seg.text) drawTextInSegment(targetCtx, seg, localCenter, localRadius);
                });
            }
            
            function drawSegmentOutlines(targetCtx, localCenter, localRadius) {
                 segments.forEach(seg => drawSegmentLine(targetCtx, timeToAngle(seg.start), localCenter, localRadius));
            }

            function drawImageInSegment(targetCtx, seg, localCenter, localRadius) {
                if (!seg.image || !(seg.image.data instanceof HTMLImageElement)) {
                    return;
                }
                const img = seg.image.data;
                const initialScale = seg.image.initialScale || 1;
                const userScale = seg.image.userScale || 1;
                const scale = initialScale * userScale;
                const offsetX = seg.image.offsetX || 0;
                const offsetY = seg.image.offsetY || 0;

                let startAngle = timeToAngle(seg.start);
                let endAngle = timeToAngle(seg.end);
                if (endAngle < startAngle) { endAngle += 2 * Math.PI; }
                const midAngle = (startAngle + endAngle) / 2;

                const drawWidth = img.width * scale;
                const drawHeight = img.height * scale;
                const imgCenterX = localCenter.x + (localRadius * 0.6) * Math.cos(midAngle) + (localRadius * offsetX);
                const imgCenterY = localCenter.y + (localRadius * 0.6) * Math.sin(midAngle) + (localRadius * offsetY);
                
                targetCtx.save();
                targetCtx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                targetCtx.shadowBlur = 15;
                targetCtx.drawImage(img, imgCenterX - drawWidth / 2, imgCenterY - drawHeight / 2, drawWidth, drawHeight);
                targetCtx.restore();
            }

            function drawTextInSegment(targetCtx, seg, localCenter, localRadius) {
                targetCtx.save();
                
                const startAngle = timeToAngle(seg.start);
                const endAngle = timeToAngle(seg.end);
                targetCtx.beginPath();
                targetCtx.moveTo(localCenter.x, localCenter.y);
                targetCtx.arc(localCenter.x, localCenter.y, localRadius, startAngle, endAngle);
                targetCtx.closePath();
                targetCtx.clip();

                targetCtx.textAlign = 'center';
                targetCtx.textBaseline = 'middle';
                targetCtx.fillStyle = seg.textColor || '#000000';
                
                if (seg.textShadow) {
                    targetCtx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    targetCtx.shadowBlur = 4;
                    targetCtx.shadowOffsetX = 2;
                    targetCtx.shadowOffsetY = 2;
                }
                
                const baseFontSize = seg.textSize || 16;
                const exportScale = localRadius / (canvas.width / 2 * 0.8);
                const fontFamily = seg.fontFamily || "'Noto Sans JP', sans-serif";
                const fontWeight = seg.fontWeight || 'normal';
                const fontStyle = seg.fontStyle || 'normal';
                targetCtx.font = `${fontStyle} ${fontWeight} ${baseFontSize * exportScale}px ${fontFamily}`;

                let midAngle = (startAngle + endAngle) / 2;
                if (endAngle < startAngle) { midAngle = (startAngle + endAngle + 2 * Math.PI) / 2; }
                
                const textOffsetX = seg.textOffsetX || 0;
                const textOffsetY = seg.textOffsetY || 0;

                const baseTextRadius = localRadius * 0.6;
                const x = localCenter.x + baseTextRadius * Math.cos(midAngle) + (localRadius * textOffsetX);
                const y = localCenter.y + baseTextRadius * Math.sin(midAngle) + (localRadius * textOffsetY);

                targetCtx.fillText(seg.text, x, y);
                targetCtx.restore();
            }
            
            function drawSegmentLine(targetCtx, angle, localCenter, localRadius) {
                targetCtx.save();
                targetCtx.beginPath();
                targetCtx.moveTo(localCenter.x, localCenter.y);
                targetCtx.lineTo(localCenter.x + localRadius * Math.cos(angle), localCenter.y + localRadius * Math.sin(angle));
                targetCtx.strokeStyle = '#333';
                targetCtx.lineWidth = settings.lineWidth || 2;
                targetCtx.stroke();
                targetCtx.restore();
            }

            function drawPercentageLabels(targetCtx, localCenter, localRadius) {
                targetCtx.save();
                const exportScale = localRadius / (canvas.width / 2 * 0.8);
                const fontSize = settings.percentageFontSize || 14;
                targetCtx.font = `bold ${fontSize * exportScale}px Arial`;
                targetCtx.fillStyle = settings.percentageFontColor || '#555555';
                targetCtx.textAlign = 'center';
                targetCtx.textBaseline = 'middle';
                const labelRadius = localRadius * 1.1;

                segments.forEach(seg => {
                    let duration = seg.end - seg.start;
                    if (duration <= 0) {
                        duration += 24;
                    }
                    const percentage = (duration / 24) * 100;
                    if (percentage < 3) return;

                    const percentageText = `${Math.round(percentage)}%`;

                    let startAngle = timeToAngle(seg.start);
                    let endAngle = timeToAngle(seg.end);
                    if (endAngle < startAngle) {
                        endAngle += 2 * Math.PI;
                    }
                    const midAngle = (startAngle + endAngle) / 2;

                    const x = localCenter.x + labelRadius * Math.cos(midAngle);
                    const y = localCenter.y + labelRadius * Math.sin(midAngle);

                    targetCtx.fillText(percentageText, x, y);
                });

                targetCtx.restore();
            }
            
            function drawOuterCircle(targetCtx, localCenter, localRadius) {
                targetCtx.save();
                targetCtx.beginPath();
                targetCtx.arc(localCenter.x, localCenter.y, localRadius, 0, 2 * Math.PI);
                targetCtx.strokeStyle = '#aaa';
                targetCtx.lineWidth = settings.lineWidth || 2;
                targetCtx.stroke();
                targetCtx.restore();
            }

            function drawHoveredTick(targetCtx, localCenter, localRadius) {
                if (hoveredTick === null) return;
                targetCtx.save();
                const angle = timeToAngle(hoveredTick);
                targetCtx.beginPath();
                targetCtx.moveTo(localCenter.x, localCenter.y);
                targetCtx.lineTo(localCenter.x + localRadius * Math.cos(angle), localCenter.y + localRadius * Math.sin(angle));
                targetCtx.strokeStyle = 'rgba(0, 100, 255, 0.5)'; targetCtx.lineWidth = 3; targetCtx.stroke();
                targetCtx.restore();
            }
            
            // --- イベントハンドラ ---
            function handleMouseMove(e) {
                const pos = getMousePos(e);
                if (draggingHandle) {
                    const angle = Math.atan2(pos.y - center.y, pos.x - center.x);
                    let time = angleToTime(angle);
                    let snappedTime = snapToNearestTick(time);

                    const segIndex = draggingHandle.segmentIndex;
                    const prevSeg = segments[(segIndex === 0) ? segments.length - 1 : segIndex - 1];
                    const currentSeg = segments[segIndex];
                    
                    const lowerBound = prevSeg.start;
                    const upperBound = currentSeg.end === 0 ? 24 : currentSeg.end;

                    let isValid = false;
                    if (lowerBound < upperBound) {
                        if (snappedTime > lowerBound && snappedTime < upperBound) {
                            isValid = true;
                        }
                    } else { 
                        if (snappedTime > lowerBound || snappedTime < upperBound) {
                            isValid = true;
                        }
                    }

                    if (isValid) {
                        currentSeg.start = snappedTime;
                        prevSeg.end = snappedTime;
                        draw();
                    }
                } else {
                    const handle = getHandleAtPos(pos);
                    if (handle) {
                        canvas.style.cursor = 'ew-resize';
                        hoveredTick = null;
                    } else {
                        const dist = Math.hypot(pos.x - center.x, pos.y - center.y);
                        if (dist > radius * 0.9 && dist < radius * 1.1) {
                            const angle = Math.atan2(pos.y - center.y, pos.x - center.x);
                            const time = snapToNearestTick(angleToTime(angle));
                            if (!isTimeOnExistingHandle(time)) {
                                hoveredTick = time;
                                canvas.style.cursor = 'pointer';
                            } else {
                                hoveredTick = null;
                                canvas.style.cursor = 'default';
                            }
                        } else {
                            hoveredTick = null;
                            canvas.style.cursor = 'default';
                        }
                    }
                    draw();
                }
            }
            
            function handleMouseDown(e) {
                if (e.button !== 0) return;
                const pos = getMousePos(e);
                const handle = getHandleAtPos(pos);
                if (handle) {
                    draggingHandle = handle;
                }
            }

            function handleMouseUp() { if(draggingHandle) { draggingHandle = null; normalizeSegments(); saveState(); draw(); } }
            function handleMouseLeave() { if(draggingHandle) { draggingHandle = null; normalizeSegments(); draw(); } hoveredTick = null; draw(); }
            
            function handleClick() {
                if (hoveredTick !== null) {
                    addSegment(hoveredTick);
                    hoveredTick = null;
                    saveState();
                    draw();
                }
            }

            function handleDragOver(e) { e.preventDefault(); e.stopPropagation(); e.dataTransfer.dropEffect = 'copy'; }

            function handleDoubleClick(e) {
                const pos = getMousePos(e);
                const angle = Math.atan2(pos.y - center.y, pos.x - center.x);
                let time = angleToTime(angle);
                const dist = Math.hypot(pos.x - center.x, pos.y - center.y);

                if (dist < radius) {
                    const targetSegment = findSegmentAtTime(time);
                    if (targetSegment) {
                        currentlyEditingSegment = targetSegment;
                        populateEditView(targetSegment);
                        switchView('edit');
                    }
                }
            }

            function handleDrop(e) {
                e.preventDefault(); e.stopPropagation();
                const file = e.dataTransfer.files[0];
                if (!file || !file.type.startsWith('image/')) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        const pos = getMousePos(e);
                        const time = angleToTime(Math.atan2(pos.y - center.y, pos.x - center.x));
                        const targetSegment = findSegmentAtTime(time);
                        if (targetSegment) {
                            const maxDim = Math.max(img.width, img.height);
                            const initialScale = (radius / maxDim) * 0.8;

                            const newImage = { 
                                data: img, 
                                initialScale: initialScale,
                                userScale: 1.0,
                                offsetX: 0, 
                                offsetY: 0 
                            };

                            if(targetSegment.image) {
                                showConfirmationModal(translations[settings.language].confirmImageReplaceTitle, translations[settings.language].confirmImageReplaceMessage, () => { 
                                    targetSegment.image = newImage;
                                    if(currentlyEditingSegment && currentlyEditingSegment.id === targetSegment.id) {
                                        populateEditView(targetSegment);
                                    }
                                    saveState(); 
                                    draw(); 
                                });
                            } else {
                                targetSegment.image = newImage; 
                                if(currentlyEditingSegment && currentlyEditingSegment.id === targetSegment.id) {
                                    populateEditView(targetSegment);
                                }
                                saveState();
                                draw();
                            }
                        }
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
            
            // --- UI制御 ---
            function switchView(viewName) {
                currentView = viewName;
                settingsView.classList.add('hidden');
                helpView.classList.add('hidden');
                editView.classList.add('hidden');
                exportView.classList.add('hidden');
                
                if (viewName === 'settings') {
                    panelBackBtn.classList.add('hidden');
                } else {
                    panelBackBtn.classList.remove('hidden');
                }

                updateUIText(settings.language, viewName);
            }
            
            function populateEditView(segment) {
                editColorInput.value = segment.color || defaultSegmentProps.color;
                editColorOpacity.value = (segment.colorOpacity ?? defaultSegmentProps.colorOpacity) * 100;
                colorOpacityValue.textContent = editColorOpacity.value;
                editTextInput.value = segment.text || defaultSegmentProps.text;
                editFontSelect.value = segment.fontFamily || defaultSegmentProps.fontFamily;
                editTextColorInput.value = segment.textColor || defaultSegmentProps.textColor;
                edittextsize.value = segment.textSize || defaultSegmentProps.textSize;
                textSizeValue.textContent = segment.textSize || defaultSegmentProps.textSize;
                fontBoldCheckbox.checked = (segment.fontWeight === 'bold');
                fontItalicCheckbox.checked = (segment.fontStyle === 'italic');
                textShadowCheckbox.checked = segment.textShadow || false;
                editTextX.value = (segment.textOffsetX || 0) * 100;
                editTextY.value = (segment.textOffsetY || 0) * 100;

                if (segment.image) {
                    imageEditSection.style.display = 'block';
                    const userScalePercent = (segment.image.userScale || 1) * 100;
                    editImageScale.value = userScalePercent;
                    scaleValue.textContent = Math.round(userScalePercent);
                    editImageX.value = (segment.image.offsetX || 0) * 100;
                    editImageY.value = (segment.image.offsetY || 0) * 100;
                } else {
                    imageEditSection.style.display = 'none';
                }
            }
            
            function updateSegmentProperty(prop, value) { if (currentlyEditingSegment) { currentlyEditingSegment[prop] = value; draw(); } }
            function updateImageProperty(prop, value) { if (currentlyEditingSegment && currentlyEditingSegment.image) { currentlyEditingSegment.image[prop] = value; draw(); } }
            
            function deleteImage() {
                if (!currentlyEditingSegment) return;
                showConfirmationModal(translations[settings.language].confirmImageDeleteTitle, translations[settings.language].confirmImageDeleteMessage, () => { 
                    updateSegmentProperty('image', null); 
                    imageEditSection.style.display = 'none'; 
                    saveState();
                    draw(); 
                });
            }

            function deleteSegment() {
                if (!currentlyEditingSegment || segments.length <= 1) return;
                showConfirmationModal(translations[settings.language].confirmSegmentDeleteTitle, translations[settings.language].confirmSegmentDeleteMessage, () => {
                    const index = segments.findIndex(s => s.id === currentlyEditingSegment.id);
                    if (index > -1) {
                        segments.splice(index, 1);
                    }
                    normalizeSegments();
                    currentlyEditingSegment = null;
                    switchView('settings');
                    saveState();
                    draw();
                });
            }

            function resetSegment() {
                if (!currentlyEditingSegment) return;

                const currentText = currentlyEditingSegment.text;
                const currentImage = currentlyEditingSegment.image;

                Object.keys(defaultSegmentProps).forEach(key => {
                    if (key !== 'text' && key !== 'image') {
                         currentlyEditingSegment[key] = JSON.parse(JSON.stringify(defaultSegmentProps[key]));
                    }
                });
                
                currentlyEditingSegment.text = currentText;
                currentlyEditingSegment.image = currentImage;

                populateEditView(currentlyEditingSegment);
                saveState();
                draw();
            }
            
            function handleBackgroundDrop(e) {
                e.preventDefault();
                e.stopPropagation();
                bgDragArea.classList.remove('drag-over');
                const file = e.dataTransfer.files[0];
                if (!file || !file.type.startsWith('image/')) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        backgroundImage = {
                            data: img,
                            opacity: 1,
                            scale: 1,
                            x: 0,
                            y: 0
                        };
                        bgImageControls.classList.remove('hidden');
                        saveState();
                        draw();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }

            function resetBackgroundImage() {
                if (!backgroundImage) return;
                backgroundImage.opacity = 1;
                backgroundImage.scale = 1;
                backgroundImage.x = 0;
                backgroundImage.y = 0;
                
                bgOpacitySlider.value = 100;
                bgOpacityValue.textContent = '100';
                bgScaleSlider.value = 100;
                bgScaleValue.textContent = '100';
                bgXSlider.value = 0;
                bgYSlider.value = 0;

                saveState();
                draw();
            }

            // --- ロジック ---
            function addSegment(time) {
                const targetIndex = findSegmentIndexAtTime(time);
                if (targetIndex === -1) return;

                const originalSegment = segments[targetIndex];
                const newSegment = {
                    id: Date.now(),
                    start: time,
                    end: originalSegment.end,
                    ...JSON.parse(JSON.stringify(defaultSegmentProps))
                };
                originalSegment.end = time;
                segments.splice(targetIndex + 1, 0, newSegment);
                normalizeSegments();
            }

            function getHandleAtPos(pos) {
                const dist = Math.hypot(pos.x - center.x, pos.y - center.y);
                if (dist < radius * 0.9 || dist > radius * 1.1) return null;
                
                const angle = Math.atan2(pos.y - center.y, pos.x - center.x);
                const time = angleToTime(angle);

                for (let i = 0; i < segments.length; i++) {
                    const handleTime = segments[i].start;
                    if (handleTime === 0 || handleTime === 24) continue;
                    const timeDiff = Math.min(Math.abs(time - handleTime), 24 - Math.abs(time - handleTime));
                    if (timeDiff < 0.1) return { segmentIndex: i };
                }
                return null;
            }

            function isTimeOnExistingHandle(time) {
                return segments.some(seg => {
                    const timeDiff = Math.min(Math.abs(time - seg.start), 24 - Math.abs(time - seg.start));
                    return timeDiff < 0.01;
                });
            }
            
            function findSegmentAtTime(time) {
                return segments.find(seg => {
                    const start = seg.start;
                    const end = (seg.end === 0) ? 24 : seg.end; // 0時を24時として扱う
                    if (start < end) return time >= start && time < end;
                    return time >= start || time < end;
                });
            }
            function findSegmentIndexAtTime(time) {
                return segments.findIndex(seg => {
                    const start = seg.start;
                    const end = (seg.end === 0) ? 24 : seg.end;
                    if (start < end) return time >= start && time < end;
                    return time >= start || time < end;
                });
            }
            
            /**
             * @description セグメントの開始・終了時刻を正規化する。
             * 削除や移動後に、各セグメントの終了時刻が次のセグメントの開始時刻と一致するように調整する。
             * 最後のセグメントの終了時刻は24(0)になるようにする。
             */
            function normalizeSegments() {
                if (segments.length === 0) return;
                if (segments.length === 1) {
                    segments[0].start = 0;
                    segments[0].end = 24;
                    return;
                }
                segments.sort((a, b) => a.start - b.start);
                
                segments[0].start = 0;

                for(let i = 0; i < segments.length - 1; i++) {
                    segments[i].end = segments[i + 1].start;
                }
                
                segments[segments.length - 1].end = 24;
            }

            function snapToNearestTick(time) {
                const tickInterval = 0.24; // 1% interval
                return Math.round(time / tickInterval) * tickInterval;
            }
            
            // --- ユーティリティ ---
            function timeToAngle(time) { return (time / 12 * Math.PI) - (Math.PI / 2); }
            function angleToTime(angle) { let t = (angle + Math.PI / 2) * 12 / Math.PI; return t < 0 ? t + 24 : t; }
            function getMousePos(evt) { const rect = canvas.getBoundingClientRect(); return { x: evt.clientX - rect.left, y: evt.clientY - rect.top }; }
            function hexToRgba(hex, alpha) {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }

            function showConfirmationModal(title, message, onConfirm) {
                modalTitle.textContent = title;
                modalMessage.innerText = message;
                
                modalConfirmBtn.style.display = 'block';
                modalCancelBtn.style.display = 'block';
                modalOkBtn.style.display = 'none';

                const newConfirmBtn = modalConfirmBtn.cloneNode(true);
                modalConfirmBtn.parentNode.replaceChild(newConfirmBtn, modalConfirmBtn);
                
                newConfirmBtn.addEventListener('click', () => {
                    onConfirm();
                    modalContainer.style.display = 'none';
                }, { once: true });

                const newCancelBtn = modalCancelBtn.cloneNode(true);
                modalCancelBtn.parentNode.replaceChild(newCancelBtn, modalCancelBtn);
                newCancelBtn.addEventListener('click', () => {
                    modalContainer.style.display = 'none';
                }, { once: true });
                
                modalContainer.style.display = 'flex';
            }

            function showNotificationModal(title, message) {
                modalTitle.textContent = title;
                modalMessage.innerText = message;
                
                modalConfirmBtn.style.display = 'none';
                modalCancelBtn.style.display = 'none';
                modalOkBtn.style.display = 'block';

                const newOkBtn = modalOkBtn.cloneNode(true);
                modalOkBtn.parentNode.replaceChild(newOkBtn, modalOkBtn);

                newOkBtn.addEventListener('click', () => {
                    modalContainer.style.display = 'none';
                }, { once: true });

                modalContainer.style.display = 'flex';
            }
            
            // --- 保存・呼び出し・出力 ---
            function imageToDataURL(img) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = img.naturalWidth;
                tempCanvas.height = img.naturalHeight;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(img, 0, 0);
                return tempCanvas.toDataURL('image/png');
            }

            function handleSave() {
                const segmentsForSave = segments.map(seg => {
                    const newSeg = {...seg};
                    if (newSeg.image && newSeg.image.data instanceof HTMLImageElement) {
                        newSeg.image.data = imageToDataURL(newSeg.image.data);
                    }
                    return newSeg;
                });

                const dataToSave = {
                    settings: settings,
                    segments: segmentsForSave,
                    backgroundImage: backgroundImage && backgroundImage.data ? { ...backgroundImage, data: imageToDataURL(backgroundImage.data) } : null
                };

                const jsonString = JSON.stringify(dataToSave, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'piechart-data.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            function dataURLToImage(dataURL) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = reject;
                    img.src = dataURL;
                });
            }

            async function handleLoad(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const loadedData = JSON.parse(e.target.result);
                        if (!loadedData.settings || !loadedData.segments) {
                            throw new Error(translations[settings.language].errorInvalidFile);
                        }

                        settings = loadedData.settings;

                        if (loadedData.backgroundImage && loadedData.backgroundImage.data) {
                            const img = await dataURLToImage(loadedData.backgroundImage.data);
                            backgroundImage = { ...loadedData.backgroundImage, data: img };
                            bgImageControls.classList.remove('hidden');
                        } else {
                            backgroundImage = null;
                            bgImageControls.classList.add('hidden');
                        }

                        const newSegments = await Promise.all(loadedData.segments.map(async (seg) => {
                            if (seg.image && seg.image.data && typeof seg.image.data === 'string') {
                                try {
                                    const img = await dataURLToImage(seg.image.data);
                                    return { ...seg, image: { ...seg.image, data: img } };
                                } catch (error) {
                                    console.error("Failed to load an image from data URL:", error);
                                    return { ...seg, image: null };
                                }
                            }
                            return seg;
                        }));

                        segments = newSegments;
                        normalizeSegments();
                        updateUIText(settings.language);
                        saveState();
                        draw();

                    } catch (error) {
                        showNotificationModal(translations[settings.language].errorLoadTitle, error.message);
                    } finally {
                        loadInput.value = '';
                    }
                };
                reader.readAsText(file);
            }
            
            function handleExport() {
                const size = parseInt(exportSizeSelect.value, 10);
                const format = exportFormatSelect.value;
                const extension = format === 'image/jpeg' ? 'jpg' : 'png';

                const exportCanvas = document.createElement('canvas');
                exportCanvas.width = size;
                exportCanvas.height = size;
                const exportCtx = exportCanvas.getContext('2d');

                draw(exportCtx, { width: size, height: size }, format);

                const dataURL = exportCanvas.toDataURL(format, 0.9);
                const a = document.createElement('a');
                a.href = dataURL;
                a.download = `piechart.${extension}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                switchView('settings');
            }

            // --- ローカルストレージ設定 ---
            function saveSettings() { localStorage.setItem('pieChartMakerSettings', JSON.stringify(settings)); }
            function loadSettings() {
                const saved = localStorage.getItem('pieChartMakerSettings');
                if (saved) {
                    const loadedSettings = JSON.parse(saved);
                    settings = { ...settings, ...loadedSettings };
                }
            }
            
            // --- Undo/Redo ---
            function saveState() {
                historyStack = historyStack.slice(0, historyIndex + 1);
                const state = {
                    segments: JSON.parse(JSON.stringify(segments)),
                    backgroundImage: JSON.parse(JSON.stringify(backgroundImage)),
                    settings: JSON.parse(JSON.stringify(settings))
                };
                historyStack.push(state);
                historyIndex = historyStack.length - 1;
            }

            async function restoreState(state) {
                settings = JSON.parse(JSON.stringify(state.settings));
                
                if (state.backgroundImage && state.backgroundImage.data) {
                    const img = await dataURLToImage(state.backgroundImage.data);
                    backgroundImage = { ...state.backgroundImage, data: img };
                } else {
                    backgroundImage = null;
                }

                const newSegments = await Promise.all(state.segments.map(async (seg) => {
                    if (seg.image && seg.image.data && typeof seg.image.data === 'string') {
                        const img = await dataURLToImage(seg.image.data);
                        return { ...seg, image: { ...seg.image, data: img } };
                    }
                    return seg;
                }));
                segments = newSegments;

                updateUIText(settings.language, currentView);
                draw();
            }

            function handleUndo() {
                if (historyIndex > 0) {
                    historyIndex--;
                    restoreState(historyStack[historyIndex]);
                }
            }

            // --- 多言語対応 ---
            const translations = {
                ja: {
                    appTitle: "画像放り込み円グラフメーカー",
                    settings: "設定", save: "保存", load: "呼び出し", export: "画像出力", help: "操作方法", langToggle: "English",
                    panelTitleSettings: "設定", panelTitleHelp: "操作方法", panelTitleEdit: "パーツの編集", panelTitleExport: "画像出力",
                    helpList: `<li><strong>区切り線の追加:</strong> 円グラフの外周付近をクリックします。</li><li><strong>区切り線の移動:</strong> 区切り線をドラッグ＆ドロップで移動できます。</li><li><strong>画像の挿入:</strong> パソコンから画像を目的のエリアにドラッグ＆ドロップします。再度ドロップすると画像は入れ替わります。</li><li><strong>編集:</strong> エリアをダブルクリックすると編集パネルが表示されます。</li><li class="ml-4"><strong>テキスト:</strong> 文字の入力、サイズ、位置を調整できます。</li>`,
                    displayOptionsTitle: "表示オプション",
                    lineWidthLabel: "線の太さ",
                    percentSizeLabel: "パーセント文字サイズ",
                    percentColorLabel: "パーセント文字色",
                    percentSizeOptions: ["極小", "小", "中", "大", "特大", "最大", "超特大"],
                    bgImageTitle: "背景画像", bgDragArea: "ここに背景画像をドロップ", bgOpacityLabel: "透過度", bgScaleLabel: "拡大・縮小", bgPosLabel: "位置", deleteBgImageBtn: "画像を削除", resetBgImageBtn: "背景画像設定をリセット",
                    editColorLabel: "背景色", editColorOpacityLabel: "透過度", editTextTitle: "テキストの編集", editTextContentLabel: "内容", editTextContentPlaceholder: "テキストを入力...", editFontLabel: "フォント", editTextColorLabel: "文字色", editTextSizeLabel: "サイズ", textPosLabel: "位置", fontBold: "太字", fontItalic: "斜体", textShadow: "影",
                    editImageTitle: "画像の調整", editImageScaleLabel: "拡大・縮小", imagePosLabel: "位置", deleteImageBtn: "画像を削除",
                    backBtn: "戻る", deleteSegmentBtn: "このパーツを削除", resetSegmentBtn: "パーツ設定をリセット",
                    exportSizeLabel: "画像サイズ", exportFormatLabel: "画像形式", exportConfirm: "出力実行",
                    confirmYes: "はい", confirmNo: "いいえ",
                    confirmImageReplaceTitle: "画像の入れ替え", confirmImageReplaceMessage: "すでにある画像を入れ替えますか？",
                    confirmImageDeleteTitle: "画像の削除", confirmImageDeleteMessage: "このパーツから画像を削除しますか？",
                    confirmSegmentDeleteTitle: "パーツの削除", confirmSegmentDeleteMessage: "このパーツを削除しますか？",
                    confirmBgImageDeleteTitle: "背景画像の削除", confirmBgImageDeleteMessage: "背景画像を削除しますか？",
                    errorLoadTitle: "読み込みエラー", errorInvalidFile: "無効なファイル形式です。",
                },
                en: {
                    appTitle: "Image Drop Pie Chart Maker",
                    settings: "Settings", save: "Save", load: "Load", export: "Export Image", help: "Help", langToggle: "日本語",
                    panelTitleSettings: "Settings", panelTitleHelp: "How to Use", panelTitleEdit: "Edit Segment", panelTitleExport: "Export Image",
                    helpList: `<li><strong>Add Divider:</strong> Click near the outer edge of the pie chart.</li><li><strong>Move Divider:</strong> Drag and drop a divider to move it.</li><li><strong>Insert Image:</strong> Drag and drop an image from your computer into a segment. Dropping another image will replace the existing one.</li><li><strong>Edit:</strong> Double-click a segment to open the edit panel.</li><li class="ml-4"><strong>Text:</strong> Adjust content, size, and position of the text.</li>`,
                    displayOptionsTitle: "Display Options",
                    lineWidthLabel: "Line Width",
                    percentSizeLabel: "Percentage Font Size",
                    percentColorLabel: "Percentage Font Color",
                    percentSizeOptions: ["X-Small", "Small", "Medium", "Large", "X-Large", "Max", "XXL"],
                    bgImageTitle: "Background Image", bgDragArea: "Drop background image here", bgOpacityLabel: "Opacity", bgScaleLabel: "Scale", bgPosLabel: "Position", deleteBgImageBtn: "Delete Image", resetBgImageBtn: "Reset Background Settings",
                    editColorLabel: "Background Color", editColorOpacityLabel: "Opacity", editTextTitle: "Edit Text", editTextContentLabel: "Content", editTextContentPlaceholder: "Enter text...", editFontLabel: "Font", editTextColorLabel: "Color", editTextSizeLabel: "Size", textPosLabel: "Position", fontBold: "Bold", fontItalic: "Italic", textShadow: "Shadow",
                    editImageTitle: "Adjust Image", editImageScaleLabel: "Scale", imagePosLabel: "Position", deleteImageBtn: "Delete Image",
                    backBtn: "Back", deleteSegmentBtn: "Delete this Segment", resetSegmentBtn: "Reset Part Settings",
                    exportSizeLabel: "Image Size", exportFormatLabel: "Image Format", exportConfirm: "Export",
                    confirmYes: "Yes", confirmNo: "No",
                    confirmImageReplaceTitle: "Replace Image", confirmImageReplaceMessage: "Do you want to replace the existing image?",
                    confirmImageDeleteTitle: "Delete Image", confirmImageDeleteMessage: "Do you want to delete the image from this segment?",
                    confirmSegmentDeleteTitle: "Delete Segment", confirmSegmentDeleteMessage: "Do you want to delete this segment?",
                    confirmBgImageDeleteTitle: "Delete Background Image", confirmBgImageDeleteMessage: "Do you want to delete the background image?",
                    errorLoadTitle: "Load Error", errorInvalidFile: "Invalid file format.",
                }
            };

            function updateUIText(lang, viewName = 'settings') {
                const t = translations[lang];
                appTitle.textContent = t.appTitle;
                saveBtn.textContent = t.save;
                loadBtn.textContent = t.load;
                exportBtn.textContent = t.export;
                helpBtn.textContent = t.help;
                langToggleBtn.textContent = t.langToggle;
                panelBackBtn.textContent = t.backBtn;
                
                const activeClasses = { help: 'bg-green-500', export: 'bg-purple-500' };
                const inactiveClass = 'bg-gray-500';
                
                helpBtn.className = helpBtn.className.replace(/bg-\w+-\d+/, inactiveClass);
                exportBtn.className = exportBtn.className.replace(/bg-\w+-\d+/, inactiveClass);

                if (viewName === 'settings') {
                    panelTitle.textContent = t.panelTitleSettings;
                    settingsView.classList.remove('hidden');
                } else if (viewName === 'help') {
                    panelTitle.textContent = t.panelTitleHelp;
                    helpView.classList.remove('hidden');
                    helpBtn.className = helpBtn.className.replace(inactiveClass, activeClasses.help);
                } else if (viewName === 'export') {
                    panelTitle.textContent = t.panelTitleExport;
                    exportView.classList.remove('hidden');
                    exportBtn.className = exportBtn.className.replace(inactiveClass, activeClasses.export);
                } else if (viewName === 'edit') {
                    panelTitle.textContent = t.panelTitleEdit;
                    editView.classList.remove('hidden');
                }

                document.getElementById('help-list').innerHTML = t.helpList;
                
                document.getElementById('display-options-title').textContent = t.displayOptionsTitle;
                document.getElementById('line-width-label-text').textContent = t.lineWidthLabel;
                document.getElementById('percent-size-label').textContent = t.percentSizeLabel;
                document.getElementById('percent-color-label').textContent = t.percentColorLabel;
                const updateOptions = (selectId, options) => {
                    const select = document.getElementById(selectId);
                    Array.from(select.options).forEach((option, i) => {
                        option.textContent = options[i];
                    });
                };
                updateOptions('percent-size-select', t.percentSizeOptions);

                lineWidthSlider.value = settings.lineWidth;
                lineWidthValue.textContent = settings.lineWidth;
                percentSizeSelect.value = settings.percentageFontSize;
                percentColorInput.value = settings.percentageFontColor;

                document.getElementById('bg-image-title').textContent = t.bgImageTitle;
                bgDragArea.textContent = t.bgDragArea;
                document.getElementById('bg-opacity-label-text').textContent = t.bgOpacityLabel;
                document.getElementById('bg-scale-label-text').textContent = t.bgScaleLabel;
                document.getElementById('bg-pos-label-text').textContent = t.bgPosLabel;
                deleteBgImageBtn.textContent = t.deleteBgImageBtn;
                resetBgImageBtn.textContent = t.resetBgImageBtn;

                document.getElementById('edit-color-label').textContent = t.editColorLabel;
                document.getElementById('edit-color-opacity-label-text').textContent = t.editColorOpacityLabel;
                document.getElementById('edit-text-title').textContent = t.editTextTitle;
                document.getElementById('edit-text-content-label').textContent = t.editTextContentLabel;
                document.getElementById('edit-text').placeholder = t.editTextContentPlaceholder;
                document.getElementById('edit-font-label').textContent = t.editFontLabel;
                document.getElementById('edit-text-color-label').textContent = t.editTextColorLabel;
                document.getElementById('edit-text-size-label-text').textContent = t.editTextSizeLabel;
                document.getElementById('font-bold-label').textContent = t.fontBold;
                document.getElementById('font-italic-label').textContent = t.fontItalic;
                document.getElementById('text-shadow-label').textContent = t.textShadow;
                document.getElementById('text-pos-label-text').textContent = t.textPosLabel;
                
                document.getElementById('edit-image-title').textContent = t.editImageTitle;
                document.getElementById('edit-image-scale-label-text').textContent = t.editImageScaleLabel;
                document.getElementById('image-pos-label-text').textContent = t.imagePosLabel;
                deleteImageBtn.textContent = t.deleteImageBtn;
                deleteSegmentBtn.textContent = t.deleteSegmentBtn;
                resetSegmentBtn.textContent = t.resetSegmentBtn;

                document.getElementById('export-size-label').textContent = t.exportSizeLabel;
                document.getElementById('export-format-label').textContent = t.exportFormatLabel;
                exportConfirmBtn.textContent = t.exportConfirm;
                
                document.getElementById('modal-confirm').textContent = t.confirmYes;
                document.getElementById('modal-cancel').textContent = t.confirmNo;
            }

            init();
        });
    </script>
</body>
</html>
